name: ðŸš€ Continuous Delivery

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: xupeng211/gitee-notion


concurrency:
  group: cd-prod
  cancel-in-progress: true

jobs:
  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image-tags: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=stable,enable={{is_default_branch}}

      - name: Build and Push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ github.sha }}
            BUILD_TIME=${{ github.run_number }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

      - name: Trivy Scan (non-blocking)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ github.sha }}
          format: table
          exit-code: 0

  pre-deploy-smoke:
    name: Pre-deploy Smoke Test
    runs-on: ubuntu-latest
    needs: [build-and-push]
    steps:
      - name: Pull and Run Image for Smoke
        env:
          IMAGE_TAGS: ${{ needs.build-and-push.outputs.image-tags }}
        run: |
          set -euo pipefail
          IMAGE=$(echo "$IMAGE_TAGS" | tr ',' '\n' | grep -E ':sha-' | head -n1)
          if [ -z "$IMAGE" ]; then
            echo "No sha tag found in: $IMAGE_TAGS" >&2; exit 1;
          fi
          docker pull "$IMAGE"
          cid=$(docker run -d -p 18000:8000 \
            -e GITEE_WEBHOOK_SECRET=test \
            -e GITHUB_WEBHOOK_SECRET=test \
            -e DEADLETTER_REPLAY_TOKEN=test \
            "$IMAGE")
          for i in $(seq 1 30); do
            if curl -fsS http://127.0.0.1:18000/health >/dev/null; then echo OK; break; fi
            sleep 1
          done
          curl -fsS http://127.0.0.1:18000/health
          docker rm -f "$cid"


  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, pre-deploy-smoke]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Validate Required Secrets
        run: |
          req=(PROD_HOST PROD_USER PROD_SSH_KEY GITEE_WEBHOOK_SECRET GITHUB_WEBHOOK_SECRET DEADLETTER_REPLAY_TOKEN)
          missing=0
          for k in "${req[@]}"; do
            if [ -z "${{ secrets[format('{0}', k)] }}" ]; then
              echo "âŒ Missing secret: $k"; missing=1;
            fi
          done
          if [ "$missing" -ne 0 ]; then
            echo "Required secrets are missing. Please set them in repo settings."; exit 1;
          fi

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/prod_key.pem
          chmod 600 ~/.ssh/prod_key.pem
          ssh-keyscan -H "${{ secrets.PROD_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Copy compose file
        run: |
          scp -i ~/.ssh/prod_key.pem -o StrictHostKeyChecking=no docker-compose.production.yml "${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}:/tmp/docker-compose.production.yml"

      - name: Remote Deploy
        env:
          GHCR_USER: ${{ github.actor }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          APP_PORT: 8000
        run: |
          ssh -i ~/.ssh/prod_key.pem -o StrictHostKeyChecking=no "${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }}" bash -s <<'EOF'
          set -euo pipefail
          APP_DIR="/opt/gitee-notion-sync"
          IMAGE="${REGISTRY}/${IMAGE_NAME}:sha-${GITHUB_SHA}"

          # Ensure Docker installed
          if ! command -v docker >/dev/null 2>&1; then
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh
            rm -f get-docker.sh
          fi

          # Try docker compose v2, fallback to docker-compose
          COMPOSE_BIN="docker compose"
          if ! docker compose version >/dev/null 2>&1; then
            if ! command -v docker-compose >/dev/null 2>&1; then
              sudo curl -sL "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            COMPOSE_BIN="docker-compose"
          fi

          # Login GHCR
          echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin

          sudo mkdir -p "${APP_DIR}" && sudo chown "$USER":"$USER" "${APP_DIR}"
          mv /tmp/docker-compose.production.yml "${APP_DIR}/docker-compose.production.yml"

          # Write .env
          cat > "${APP_DIR}/.env" <<ENV_EOF
          LOG_LEVEL=INFO
          ENVIRONMENT=production
          APP_PORT=${APP_PORT}
          DB_URL=${DB_URL:-sqlite:///data/sync.db}
          REGISTRY=${REGISTRY}
          IMAGE_NAME=${IMAGE_NAME}
          IMAGE_TAG=latest
          SERVICE_PORT=${APP_PORT}
          RATE_LIMIT_PER_MINUTE=60
          MAX_REQUEST_SIZE=1048576
          GITEE_WEBHOOK_SECRET=${{ secrets.GITEE_WEBHOOK_SECRET }}
          GITHUB_WEBHOOK_SECRET=${{ secrets.GITHUB_WEBHOOK_SECRET }}
          DEADLETTER_REPLAY_TOKEN=${{ secrets.DEADLETTER_REPLAY_TOKEN }}
          NOTION_TOKEN=${{ secrets.NOTION_TOKEN || '' }}
          NOTION_DATABASE_ID=${{ secrets.NOTION_DATABASE_ID || '' }}
          ENV_EOF

          cd "${APP_DIR}"

          # Pull & start
          docker pull "${IMAGE}" || true
          ${COMPOSE_BIN} -f docker-compose.production.yml down || true
          ${COMPOSE_BIN} -f docker-compose.production.yml up -d

          # Wait for health
          for i in {1..60}; do
            if curl -sf http://localhost:${APP_PORT}/health >/dev/null 2>&1; then
              echo "âœ… Service healthy"; exit 0; fi
            if [ "$i" -eq 60 ]; then break; fi
            sleep 1
          done

          echo "âŒ Health check failed. Rolling back to :stable"
          sed -i 's/IMAGE_TAG=.*/IMAGE_TAG=stable/' .env || true
          docker pull "${REGISTRY}/${IMAGE_NAME}:stable" || true
          ${COMPOSE_BIN} -f docker-compose.production.yml down || true
          ${COMPOSE_BIN} -f docker-compose.production.yml up -d
          sleep 10
          curl -sf http://localhost:${APP_PORT}/health || (echo "Rollback also failed" && exit 1)
          echo "âœ… Rolled back to stable successfully"
          EOF

      - name: Summary
        run: |
          echo "## ðŸš€ CD Summary" >> $GITHUB_STEP_SUMMARY
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "Tags: latest, stable, sha-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
